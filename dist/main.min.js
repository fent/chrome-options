/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/chrome-options.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/atoa/atoa.js":
/*!***********************************!*\
  !*** ./node_modules/atoa/atoa.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }


/***/ }),

/***/ "./node_modules/c-p/color-picker-h.png":
/*!*********************************************!*\
  !*** ./node_modules/c-p/color-picker-h.png ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArICIwYzUwMmViMmE3YTQ5OWY0NjAzODNhYjA4YzMwOTZjNi5wbmciOw=="

/***/ }),

/***/ "./node_modules/c-p/color-picker-sv.png":
/*!**********************************************!*\
  !*** ./node_modules/c-p/color-picker-sv.png ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArICJjYWM4ZDg2ZDNiNGMyNzMxY2FmY2VkNTA5ZDRiMjZjNC5wbmciOw=="

/***/ }),

/***/ "./node_modules/c-p/color-picker.css":
/*!*******************************************!*\
  !*** ./node_modules/c-p/color-picker.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../css-loader!./color-picker.css */ "./node_modules/css-loader/index.js!./node_modules/c-p/color-picker.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/c-p/color-picker.js":
/*!******************************************!*\
  !*** ./node_modules/c-p/color-picker.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * ==========================================================
 *  COLOR PICKER PLUGIN 1.4.0
 * ==========================================================
 * Author: Taufik Nurrohman <https://github.com/tovic>
 * License: MIT
 * ----------------------------------------------------------
 */

(function(win, doc, NS) {

    var instance = '__instance__',
        first = 'firstChild',
        delay = setTimeout;

    function is_set(x) {
        return typeof x !== "undefined";
    }

    function is_string(x) {
        return typeof x === "string";
    }

    function is_object(x) {
        return typeof x === "object";
    }

    function object_length(x) {
        return Object.keys(x).length;
    }

    function edge(a, b, c) {
        if (a < b) return b;
        if (a > c) return c;
        return a;
    }

    function num(i, j) {
        return parseInt(i, j || 10);
    }

    function round(i) {
        return Math.round(i);
    }

    // [h, s, v] ... 0 <= h, s, v <= 1
    function HSV2RGB(a) {
        var h = +a[0],
            s = +a[1],
            v = +a[2],
            r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        i = i || 0;
        q = q || 0;
        t = t || 0;
        switch (i % 6) {
            case 0:
                r = v, g = t, b = p;
                break;
            case 1:
                r = q, g = v, b = p;
                break;
            case 2:
                r = p, g = v, b = t;
                break;
            case 3:
                r = p, g = q, b = v;
                break;
            case 4:
                r = t, g = p, b = v;
                break;
            case 5:
                r = v, g = p, b = q;
                break;
        }
        return [round(r * 255), round(g * 255), round(b * 255)];
    }

    function HSV2HEX(a) {
        return RGB2HEX(HSV2RGB(a));
    }

    // [r, g, b] ... 0 <= r, g, b <= 255
    function RGB2HSV(a) {
        var r = +a[0],
            g = +a[1],
            b = +a[2],
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            d = max - min,
            h, s = (max === 0 ? 0 : d / max),
            v = max / 255;
        switch (max) {
            case min:
                h = 0;
                break;
            case r:
                h = (g - b) + d * (g < b ? 6 : 0);
                h /= 6 * d;
                break;
            case g:
                h = (b - r) + d * 2;
                h /= 6 * d;
                break;
            case b:
                h = (r - g) + d * 4;
                h /= 6 * d;
                break;
        }
        return [h, s, v];
    }

    function RGB2HEX(a) {
        var s = +a[2] | (+a[1] << 8) | (+a[0] << 16);
        s = '000000' + s.toString(16);
        return s.slice(-6);
    }

    // rrggbb or rgb
    function HEX2HSV(s) {
        return RGB2HSV(HEX2RGB(s));
    }

    function HEX2RGB(s) {
        if (s.length === 3) {
            s = s.replace(/./g, '$&$&');
        }
        return [num(s[0] + s[1], 16), num(s[2] + s[3], 16), num(s[4] + s[5], 16)];
    }

    // convert range from `0` to `360` and `0` to `100` in color into range from `0` to `1`
    function _2HSV_pri(a) {
        return [+a[0] / 360, +a[1] / 100, +a[2] / 100];
    }

    // convert range from `0` to `1` into `0` to `360` and `0` to `100` in color
    function _2HSV_pub(a) {
        return [round(+a[0] * 360), round(+a[1] * 100), round(+a[2] * 100)];
    }

    // convert range from `0` to `255` in color into range from `0` to `1`
    function _2RGB_pri(a) {
        return [+a[0] / 255, +a[1] / 255, +a[2] / 255];
    }

    // *
    function parse(x) {
        if (is_object(x)) return x;
        var rgb = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i.exec(x),
            hsv = /\s*hsv\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)\s*$/i.exec(x),
            hex = x[0] === '#' && x.match(/^#([\da-f]{3}|[\da-f]{6})$/i);
        if (hex) {
            return HEX2HSV(x.slice(1));
        } else if (hsv) {
            return _2HSV_pri([+hsv[1], +hsv[2], +hsv[3]]);
        } else if (rgb) {
            return RGB2HSV([+rgb[1], +rgb[2], +rgb[3]]);
        }
        return [0, 1, 1]; // default is red
    }

    (function($) {

        // plugin version
        $.version = '1.4.0';

        // collect all instance(s)
        $[instance] = {};

        // plug to all instance(s)
        $.each = function(fn, t) {
            return delay(function() {
                var ins = $[instance], i;
                for (i in ins) {
                    fn.call(ins[i], i, ins);
                }
            }, t === 0 ? 0 : (t || 1)), $;
        };

        // static method(s)
        $.parse = parse;
        $._HSV2RGB = HSV2RGB;
        $._HSV2HEX = HSV2HEX;
        $._RGB2HSV = RGB2HSV;
        $._HEX2HSV = HEX2HSV;
        $._HEX2RGB = function(a) {
            return _2RGB_pri(HEX2RGB(a));
        };
        $.HSV2RGB = function(a) {
            return HSV2RGB(_2HSV_pri(a));
        };
        $.HSV2HEX = function(a) {
            return HSV2HEX(_2HSV_pri(a));
        };
        $.RGB2HSV = function(a) {
            return _2HSV_pub(RGB2HSV(a));
        };
        $.RGB2HEX = RGB2HEX;
        $.HEX2HSV = function(s) {
            return _2HSV_pub(HEX2HSV(s));
        };
        $.HEX2RGB = HEX2RGB;

    })(win[NS] = function(source, events, parent) {

        var b = doc.body,
            h = doc.documentElement,
            $ = this,
            $$ = win[NS],
            _ = false,
            hooks = {},
            self = doc.createElement('div'),
            on_down = "touchstart mousedown",
            on_move = "touchmove mousemove",
            on_up = "touchend mouseup",
            on_resize = "orientationchange resize";

        // return a new instance if `CP` was called without the `new` operator
        if (!($ instanceof $$)) {
            return new $$(source, events);
        }

        // store color picker instance to `CP.__instance__`
        $$[instance][source.id || source.name || object_length($$[instance])] = $;

        // trigger color picker panel on click by default
        if (!is_set(events) || events === true) {
            events = on_down;
        }

        // add event
        function on(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.addEventListener(ev[i], fn, false);
            }
        }

        // remove event
        function off(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.removeEventListener(ev[i], fn);
            }
        }

        // get mouse/finger coordinate
        function point(el, e) {
            var T = 'touches',
                X = 'clientX',
                Y = 'clientY',
                x = !!e[T] ? e[T][0][X] : e[X],
                y = !!e[T] ? e[T][0][Y] : e[Y],
                o = offset(el);
            return {
                x: x - o.l,
                y: y - o.t
            };
        }

        // get position
        function offset(el) {
            var left, top, rect;
            if (el === win) {
                left = win.pageXOffset || h.scrollLeft;
                top = win.pageYOffset || h.scrollTop;
            } else {
                rect = el.getBoundingClientRect();
                left = rect.left;
                top = rect.top;
            }
            return {
                l: left,
                t: top
            };
        }

        // get closest parent
        function closest(a, b) {
            while ((a = a.parentElement) && a !== b);
            return a;
        }

        // prevent default
        function prevent(e) {
            if (e) e.preventDefault();
        }

        // get dimension
        function size(el) {
            return el === win ? {
                w: win.innerWidth,
                h: win.innerHeight
            } : {
                w: el.offsetWidth,
                h: el.offsetHeight
            };
        }

        // get color data
        function get_data(a) {
            return _ || (is_set(a) ? a : false);
        }

        // set color data
        function set_data(a) {
            _ = a;
        }

        // add hook
        function add(ev, fn, id) {
            if (!is_set(ev)) return hooks;
            if (!is_set(fn)) return hooks[ev];
            if (!is_set(hooks[ev])) hooks[ev] = {};
            if (!is_set(id)) id = object_length(hooks[ev]);
            return hooks[ev][id] = fn, $;
        }

        // remove hook
        function remove(ev, id) {
            if (!is_set(ev)) return hooks = {}, $;
            if (!is_set(id)) return hooks[ev] = {}, $;
            return delete hooks[ev][id], $;
        }

        // trigger hook
        function trigger(ev, a, id) {
            if (!is_set(hooks[ev])) return $;
            if (!is_set(id)) {
                for (var i in hooks[ev]) {
                    hooks[ev][i].apply($, a);
                }
            } else {
                if (is_set(hooks[ev][id])) {
                    hooks[ev][id].apply($, a);
                }
            }
            return $;
        }

        // initialize data ...
        set_data($$.parse(source.getAttribute('data-color') || source.value || [0, 1, 1]));

        // generate color picker pane ...
        self.className = 'color-picker';
        self.innerHTML = '<div class="color-picker-container"><span class="color-picker-h"><i></i></span><span class="color-picker-sv"><i></i></span></div>';
        var c = self[first].children,
            HSV = get_data([0, 1, 1]), // default is red
            H = c[0],
            SV = c[1],
            H_point = H[first],
            SV_point = SV[first],
            start_H = 0,
            start_SV = 0,
            drag_H = 0,
            drag_SV = 0,
            left = 0,
            top = 0,
            P_W = 0,
            P_H = 0,
            v = HSV2HEX(HSV),
            set;

        // on update ...
        function trigger_(k, x) {
            if (!k || k === "h") {
                trigger("change:h", x);
            }
            if (!k || k === "sv") {
                trigger("change:sv", x);
            }
            trigger("change", x);
        }

        // is visible?
        function visible() {
            return self.parentNode;
        }

        // create
        function create(first, bucket) {
            if (!first) {
                (parent || bucket || b).appendChild(self), $.visible = true;
            }
            P_W = size(self).w;
            P_H = size(self).h;
            var SV_size = size(SV),
                SV_point_size = size(SV_point),
                H_H = size(H).h,
                SV_W = SV_size.w,
                SV_H = SV_size.h,
                H_point_H = size(H_point).h,
                SV_point_W = SV_point_size.w,
                SV_point_H = SV_point_size.h;
            if (first) {
                self.style.left = self.style.top = '-9999px';
                function click(e) {
                    var t = e.target,
                        is_source = t === source || closest(t, source) === source;
                    if (is_source) {
                        create();
                    } else {
                        $.exit();
                    }
                    trigger(is_source ? "enter" : "exit", [$]);
                }
                if (events !== false) {
                    on(events, source, click);
                }
                $.create = function() {
                    return create(1), trigger("create", [$]), $;
                };
                $.destroy = function() {
                    if (events !== false) {
                        off(events, source, click);
                    }
                    $.exit(), set_data(false);
                    return trigger("destroy", [$]), $;
                };
            } else {
                fit();
            }
            set = function() {
                HSV = get_data(HSV), color();
                H_point.style.top = (H_H - (H_point_H / 2) - (H_H * +HSV[0])) + 'px';
                SV_point.style.right = (SV_W - (SV_point_W / 2) - (SV_W * +HSV[1])) + 'px';
                SV_point.style.top = (SV_H - (SV_point_H / 2) - (SV_H * +HSV[2])) + 'px';
            };
            $.exit = function(e) {
                if (visible()) {
                    visible().removeChild(self);
                    $.visible = false;
                }
                off(on_down, H, down_H);
                off(on_down, SV, down_SV);
                off(on_move, doc, move);
                off(on_up, doc, stop);
                off(on_resize, win, fit);
                return $;
            };
            function color(e) {
                var a = HSV2RGB(HSV),
                    b = HSV2RGB([HSV[0], 1, 1]);
                SV.style.backgroundColor = 'rgb(' + b.join(',') + ')';
                set_data(HSV);
                prevent(e);
            };
            set();
            function do_H(e) {
                var y = edge(point(H, e).y, 0, H_H);
                HSV[0] = (H_H - y) / H_H;
                H_point.style.top = (y - (H_point_H / 2)) + 'px';
                color(e);
            }
            function do_SV(e) {
                var o = point(SV, e),
                    x = edge(o.x, 0, SV_W),
                    y = edge(o.y, 0, SV_H);
                HSV[1] = 1 - ((SV_W - x) / SV_W);
                HSV[2] = (SV_H - y) / SV_H;
                SV_point.style.right = (SV_W - x - (SV_point_W / 2)) + 'px';
                SV_point.style.top = (y - (SV_point_H / 2)) + 'px';
                color(e);
            }
            function move(e) {
                if (drag_H) {
                    do_H(e), v = HSV2HEX(HSV);
                    if (!start_H) {
                        trigger("drag:h", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("h", [v, $]);
                    }
                }
                if (drag_SV) {
                    do_SV(e), v = HSV2HEX(HSV);
                    if (!start_SV) {
                        trigger("drag:sv", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("sv", [v, $]);
                    }
                }
                start_H = 0,
                start_SV = 0;
            }
            function stop(e) {
                var t = e.target,
                    k = drag_H ? "h" : "sv",
                    a = [HSV2HEX(HSV), $],
                    is_source = t === source || closest(t, source) === source,
                    is_self = t === self || closest(t, self) === self;
                if (!is_source && !is_self) {
                    // click outside the source or picker element to exit
                    if (visible() && events !== false) $.exit(), trigger("exit", [$]), trigger_(0, a);
                } else {
                    if (is_self) {
                        trigger("stop:" + k, a);
                        trigger("stop", a);
                        trigger_(k, a);
                    }
                }
                drag_H = 0,
                drag_SV = 0;
            }
            function down_H(e) {
                start_H = 1,
                drag_H = 1,
                move(e), prevent(e);
                trigger("start:h", [v, $]);
                trigger("start", [v, $]);
                trigger_("h", [v, $]);
            }
            function down_SV(e) {
                start_SV = 1,
                drag_SV = 1,
                move(e), prevent(e);
                trigger("start:sv", [v, $]);
                trigger("start", [v, $]);
                trigger_("sv", [v, $]);
            }
            if (!first) {
                on(on_down, H, down_H);
                on(on_down, SV, down_SV);
                on(on_move, doc, move);
                on(on_up, doc, stop);
                on(on_resize, win, fit);
            }
        } create(1);

        delay(function() {
            var a = [HSV2HEX(HSV), $];
            trigger("create", a);
            trigger_(0, a);
        }, 0);

        // fit to window
        $.fit = function(o) {
            var w = size(win),
                y = size(h),
                screen_w = w.w - y.w, // vertical scroll bar
                screen_h = w.h - h.clientHeight, // horizontal scroll bar
                ww = offset(win),
                to = offset(source);
            left = to.l + ww.l;
            top = to.t + ww.t + size(source).h; // drop!
            if (is_object(o)) {
                is_set(o[0]) && (left = o[0]);
                is_set(o[1]) && (top = o[1]);
            } else {
                var min_x = ww.l,
                    min_y = ww.t,
                    max_x = ww.l + w.w - P_W - screen_w,
                    max_y = ww.t + w.h - P_H - screen_h;
                left = edge(left, min_x, max_x) >> 0;
                top = edge(top, min_y, max_y) >> 0;
            }
            self.style.left = left + 'px';
            self.style.top = top + 'px';
            return trigger("fit", [$]), $;
        };

        // for event listener ID
        function fit() {
            return $.fit();
        }

        // set hidden color picker data
        $.set = function(a) {
            if (!is_set(a)) return get_data();
            if (is_string(a)) {
                a = $$.parse(a);
            }
            return set_data(a), set(), $;
        };

        // alias for `$.set()`
        $.get = function(a) {
            return get_data(a);
        };

        // register to global ...
        $.source = source;
        $.self = self;
        $.visible = false;
        $.on = add;
        $.off = remove;
        $.fire = trigger;
        $.hooks = hooks;
        $.enter = function(bucket) {
            return create(0, bucket);
        };

        // return the global object
        return $;

    });

})(window, document, 'CP');

/***/ }),

/***/ "./node_modules/contra/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/contra/debounce.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ticky = __webpack_require__(/*! ticky */ "./node_modules/ticky/ticky-browser.js");

module.exports = function debounce (fn, args, ctx) {
  if (!fn) { return; }
  ticky(function run () {
    fn.apply(ctx || null, args || []);
  });
};


/***/ }),

/***/ "./node_modules/contra/emitter.js":
/*!****************************************!*\
  !*** ./node_modules/contra/emitter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var atoa = __webpack_require__(/*! atoa */ "./node_modules/atoa/atoa.js");
var debounce = __webpack_require__(/*! ./debounce */ "./node_modules/contra/debounce.js");

module.exports = function emitter (thing, options) {
  var opts = options || {};
  var evt = {};
  if (thing === undefined) { thing = {}; }
  thing.on = function (type, fn) {
    if (!evt[type]) {
      evt[type] = [fn];
    } else {
      evt[type].push(fn);
    }
    return thing;
  };
  thing.once = function (type, fn) {
    fn._once = true; // thing.off(fn) still works!
    thing.on(type, fn);
    return thing;
  };
  thing.off = function (type, fn) {
    var c = arguments.length;
    if (c === 1) {
      delete evt[type];
    } else if (c === 0) {
      evt = {};
    } else {
      var et = evt[type];
      if (!et) { return thing; }
      et.splice(et.indexOf(fn), 1);
    }
    return thing;
  };
  thing.emit = function () {
    var args = atoa(arguments);
    return thing.emitterSnapshot(args.shift()).apply(this, args);
  };
  thing.emitterSnapshot = function (type) {
    var et = (evt[type] || []).slice(0);
    return function () {
      var args = atoa(arguments);
      var ctx = this || thing;
      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }
      et.forEach(function emitter (listen) {
        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }
        if (listen._once) { thing.off(type, listen); }
      });
      return thing;
    };
  };
  return thing;
};


/***/ }),

/***/ "./node_modules/crossvent/src/crossvent.js":
/*!*************************************************!*\
  !*** ./node_modules/crossvent/src/crossvent.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var customEvent = __webpack_require__(/*! custom-event */ "./node_modules/custom-event/index.js");
var eventmap = __webpack_require__(/*! ./eventmap */ "./node_modules/crossvent/src/eventmap.js");
var doc = global.document;
var addEvent = addEventEasy;
var removeEvent = removeEventEasy;
var hardCache = [];

if (!global.addEventListener) {
  addEvent = addEventHard;
  removeEvent = removeEventHard;
}

module.exports = {
  add: addEvent,
  remove: removeEvent,
  fabricate: fabricateEvent
};

function addEventEasy (el, type, fn, capturing) {
  return el.addEventListener(type, fn, capturing);
}

function addEventHard (el, type, fn) {
  return el.attachEvent('on' + type, wrap(el, type, fn));
}

function removeEventEasy (el, type, fn, capturing) {
  return el.removeEventListener(type, fn, capturing);
}

function removeEventHard (el, type, fn) {
  var listener = unwrap(el, type, fn);
  if (listener) {
    return el.detachEvent('on' + type, listener);
  }
}

function fabricateEvent (el, type, model) {
  var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();
  if (el.dispatchEvent) {
    el.dispatchEvent(e);
  } else {
    el.fireEvent('on' + type, e);
  }
  function makeClassicEvent () {
    var e;
    if (doc.createEvent) {
      e = doc.createEvent('Event');
      e.initEvent(type, true, true);
    } else if (doc.createEventObject) {
      e = doc.createEventObject();
    }
    return e;
  }
  function makeCustomEvent () {
    return new customEvent(type, { detail: model });
  }
}

function wrapperFactory (el, type, fn) {
  return function wrapper (originalEvent) {
    var e = originalEvent || global.event;
    e.target = e.target || e.srcElement;
    e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; };
    e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };
    e.which = e.which || e.keyCode;
    fn.call(el, e);
  };
}

function wrap (el, type, fn) {
  var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);
  hardCache.push({
    wrapper: wrapper,
    element: el,
    type: type,
    fn: fn
  });
  return wrapper;
}

function unwrap (el, type, fn) {
  var i = find(el, type, fn);
  if (i) {
    var wrapper = hardCache[i].wrapper;
    hardCache.splice(i, 1); // free up a tad of memory
    return wrapper;
  }
}

function find (el, type, fn) {
  var i, item;
  for (i = 0; i < hardCache.length; i++) {
    item = hardCache[i];
    if (item.element === el && item.type === type && item.fn === fn) {
      return i;
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/crossvent/src/eventmap.js":
/*!************************************************!*\
  !*** ./node_modules/crossvent/src/eventmap.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var eventmap = [];
var eventname = '';
var ron = /^on/;

for (eventname in global) {
  if (ron.test(eventname)) {
    eventmap.push(eventname.slice(2));
  }
}

module.exports = eventmap;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/c-p/color-picker.css":
/*!*********************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/c-p/color-picker.css ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".color-picker,\n.color-picker::before,\n.color-picker::after,\n.color-picker *,\n.color-picker *::before,\n.color-picker *::after {\n  -webkit-box-sizing:border-box;\n  -moz-box-sizing:border-box;\n  box-sizing:border-box;\n}\n.color-picker {\n  position:absolute;\n  top:0;\n  left:0;\n  z-index:9999;\n}\n.color-picker-container {\n  background:#000;\n  color:#000;\n  padding:1px;\n  -webkit-box-shadow:1px 5px 10px rgba(0,0,0,.5);\n  -moz-box-shadow:1px 5px 10px rgba(0,0,0,.5);\n  box-shadow:1px 5px 10px rgba(0,0,0,.5);\n  width:calc(11.5em + 3px); /* TODO */\n}\n.color-picker-container *,\n.color-picker-container *::before,\n.color-picker-container *::after {border-color:inherit}\n.color-picker-container::after {\n  content:\"\";\n  display:table;\n  clear:both;\n}\n.color-picker i {\n  font:inherit;\n  font-size:12px; /* measure the color control size by measuring the text size */\n}\n.color-picker-h {\n  position:relative;\n  width:1.5em;\n  height:10em;\n  float:right;\n  cursor:ns-resize;\n  background:transparent url(" + escape(__webpack_require__(/*! ./color-picker-h.png */ "./node_modules/c-p/color-picker-h.png")) + ") no-repeat 50% 50%;\n  background-image:-webkit-linear-gradient(to top,#f00 0%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00 100%);\n  background-image:-moz-linear-gradient(to top,#f00 0%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00 100%);\n  background-image:linear-gradient(to top,#f00 0%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00 100%);\n  -webkit-background-size:100% 100%;\n  -moz-background-size:100% 100%;\n  background-size:100% 100%;\n  overflow:hidden;\n}\n.color-picker-h i {\n  position:absolute;\n  top:-.25em;\n  right:0;\n  left:0;\n  z-index:3;\n  display:block;\n  height:.5em;\n}\n.color-picker-h i::before {\n  content:\"\";\n  position:absolute;\n  top:0;\n  right:0;\n  bottom:0;\n  left:0;\n  display:block;\n  border:.25em solid;\n  border-color:inherit;\n  border-top-color:transparent;\n  border-bottom-color:transparent;\n}\n.color-picker-sv {\n  position:relative;\n  width:10em;\n  height:10em;\n  float:left;\n  margin-right:1px;\n  background:transparent url(" + escape(__webpack_require__(/*! ./color-picker-sv.png */ "./node_modules/c-p/color-picker-sv.png")) + ") no-repeat 50% 50%;\n  background-image:-webkit-linear-gradient(to top,#000,rgba(0,0,0,0)),linear-gradient(to right,#fff,rgba(255,255,255,0));\n  background-image:-moz-linear-gradient(to top,#000,rgba(0,0,0,0)),linear-gradient(to right,#fff,rgba(255,255,255,0));\n  background-image:linear-gradient(to top,#000,rgba(0,0,0,0)),linear-gradient(to right,#fff,rgba(255,255,255,0));\n  -webkit-background-size:100% 100%;\n  -moz-background-size:100% 100%;\n  background-size:100% 100%;\n  cursor:crosshair;\n}\n.color-picker-sv i {\n  position:absolute;\n  top:-.4em;\n  right:-.4em;\n  z-index:3;\n  display:block;\n  width:.8em;\n  height:.8em;\n}\n.color-picker-sv i::before,\n.color-picker-sv i::after {\n  content:\"\";\n  position:absolute;\n  top:0;\n  right:0;\n  bottom:0;\n  left:0;\n  display:block;\n  border:1px solid;\n  border-color:inherit;\n  -webkit-border-radius:100%;\n  -moz-border-radius:100%;\n  border-radius:100%;\n}\n.color-picker-sv i::before {\n  top:-1px;\n  right:-1px;\n  bottom:-1px;\n  left:-1px;\n  border-color:#fff;\n}\n.color-picker-h,\n.color-picker-sv {\n  -webkit-touch-callout:none;\n  -webkit-user-select:none;\n  -moz-user-select:none;\n  -ms-user-select:none;\n  user-select:none;\n  -webkit-tap-highlight-color:rgba(0,0,0,0);\n  -webkit-tap-highlight-color:transparent;\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/dragula/dist/dragula.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/dragula/dist/dragula.css ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".gu-mirror {\n  position: fixed !important;\n  margin: 0 !important;\n  z-index: 9999 !important;\n  opacity: 0.8;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=80)\";\n  filter: alpha(opacity=80);\n}\n.gu-hide {\n  display: none !important;\n}\n.gu-unselectable {\n  -webkit-user-select: none !important;\n  -moz-user-select: none !important;\n  -ms-user-select: none !important;\n  user-select: none !important;\n}\n.gu-transit {\n  opacity: 0.2;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=20)\";\n  filter: alpha(opacity=20);\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function escape(url) {
    if (typeof url !== 'string') {
        return url
    }
    // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        url = url.slice(1, -1);
    }
    // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url)) {
        return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"'
    }

    return url
}


/***/ }),

/***/ "./node_modules/custom-event/index.js":
/*!********************************************!*\
  !*** ./node_modules/custom-event/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
var NativeCustomEvent = global.CustomEvent;

function useNative () {
  try {
    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
    return  'cat' === p.type && 'bar' === p.detail.foo;
  } catch (e) {
  }
  return false;
}

/**
 * Cross-browser `CustomEvent` constructor.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
 *
 * @public
 */

module.exports = useNative() ? NativeCustomEvent :

// IE >= 9
'function' === typeof document.createEvent ? function CustomEvent (type, params) {
  var e = document.createEvent('CustomEvent');
  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, void 0);
  }
  return e;
} :

// IE <= 8
function CustomEvent (type, params) {
  var e = document.createEventObject();
  e.type = type;
  if (params) {
    e.bubbles = Boolean(params.bubbles);
    e.cancelable = Boolean(params.cancelable);
    e.detail = params.detail;
  } else {
    e.bubbles = false;
    e.cancelable = false;
    e.detail = void 0;
  }
  return e;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/dragula/classes.js":
/*!*****************************************!*\
  !*** ./node_modules/dragula/classes.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cache = {};
var start = '(?:^|\\s)';
var end = '(?:\\s|$)';

function lookupClass (className) {
  var cached = cache[className];
  if (cached) {
    cached.lastIndex = 0;
  } else {
    cache[className] = cached = new RegExp(start + className + end, 'g');
  }
  return cached;
}

function addClass (el, className) {
  var current = el.className;
  if (!current.length) {
    el.className = className;
  } else if (!lookupClass(className).test(current)) {
    el.className += ' ' + className;
  }
}

function rmClass (el, className) {
  el.className = el.className.replace(lookupClass(className), ' ').trim();
}

module.exports = {
  add: addClass,
  rm: rmClass
};


/***/ }),

/***/ "./node_modules/dragula/dist/dragula.css":
/*!***********************************************!*\
  !*** ./node_modules/dragula/dist/dragula.css ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../css-loader!./dragula.css */ "./node_modules/css-loader/index.js!./node_modules/dragula/dist/dragula.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/dragula/dragula.js":
/*!*****************************************!*\
  !*** ./node_modules/dragula/dragula.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var emitter = __webpack_require__(/*! contra/emitter */ "./node_modules/contra/emitter.js");
var crossvent = __webpack_require__(/*! crossvent */ "./node_modules/crossvent/src/crossvent.js");
var classes = __webpack_require__(/*! ./classes */ "./node_modules/dragula/classes.js");
var doc = document;
var documentElement = doc.documentElement;

function dragula (initialContainers, options) {
  var len = arguments.length;
  if (len === 1 && Array.isArray(initialContainers) === false) {
    options = initialContainers;
    initialContainers = [];
  }
  var _mirror; // mirror image
  var _source; // source container
  var _item; // item being dragged
  var _offsetX; // reference x
  var _offsetY; // reference y
  var _moveX; // reference move x
  var _moveY; // reference move y
  var _initialSibling; // reference sibling when grabbed
  var _currentSibling; // reference sibling now
  var _copy; // item used for copying
  var _renderTimer; // timer for setTimeout renderMirrorImage
  var _lastDropTarget = null; // last container item was over
  var _grabbed; // holds mousedown context until first mousemove

  var o = options || {};
  if (o.moves === void 0) { o.moves = always; }
  if (o.accepts === void 0) { o.accepts = always; }
  if (o.invalid === void 0) { o.invalid = invalidTarget; }
  if (o.containers === void 0) { o.containers = initialContainers || []; }
  if (o.isContainer === void 0) { o.isContainer = never; }
  if (o.copy === void 0) { o.copy = false; }
  if (o.copySortSource === void 0) { o.copySortSource = false; }
  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }
  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }
  if (o.direction === void 0) { o.direction = 'vertical'; }
  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }
  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }

  var drake = emitter({
    containers: o.containers,
    start: manualStart,
    end: end,
    cancel: cancel,
    remove: remove,
    destroy: destroy,
    canMove: canMove,
    dragging: false
  });

  if (o.removeOnSpill === true) {
    drake.on('over', spillOver).on('out', spillOut);
  }

  events();

  return drake;

  function isContainer (el) {
    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);
  }

  function events (remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousedown', grab);
    touchy(documentElement, op, 'mouseup', release);
  }

  function eventualMovements (remove) {
    var op = remove ? 'remove' : 'add';
    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);
  }

  function movements (remove) {
    var op = remove ? 'remove' : 'add';
    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8
    crossvent[op](documentElement, 'click', preventGrabbed);
  }

  function destroy () {
    events(true);
    release({});
  }

  function preventGrabbed (e) {
    if (_grabbed) {
      e.preventDefault();
    }
  }

  function grab (e) {
    _moveX = e.clientX;
    _moveY = e.clientY;

    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;
    if (ignore) {
      return; // we only care about honest-to-god left clicks and touch events
    }
    var item = e.target;
    var context = canStart(item);
    if (!context) {
      return;
    }
    _grabbed = context;
    eventualMovements();
    if (e.type === 'mousedown') {
      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208
        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176
      } else {
        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155
      }
    }
  }

  function startBecauseMouseMoved (e) {
    if (!_grabbed) {
      return;
    }
    if (whichMouseButton(e) === 0) {
      release({});
      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope
    }
    // truthy check fixes #239, equality fixes #207
    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {
      return;
    }
    if (o.ignoreInputTextSelection) {
      var clientX = getCoord('clientX', e);
      var clientY = getCoord('clientY', e);
      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);
      if (isInput(elementBehindCursor)) {
        return;
      }
    }

    var grabbed = _grabbed; // call to end() unsets _grabbed
    eventualMovements(true);
    movements();
    end();
    start(grabbed);

    var offset = getOffset(_item);
    _offsetX = getCoord('pageX', e) - offset.left;
    _offsetY = getCoord('pageY', e) - offset.top;

    classes.add(_copy || _item, 'gu-transit');
    renderMirrorImage();
    drag(e);
  }

  function canStart (item) {
    if (drake.dragging && _mirror) {
      return;
    }
    if (isContainer(item)) {
      return; // don't drag container itself
    }
    var handle = item;
    while (getParent(item) && isContainer(getParent(item)) === false) {
      if (o.invalid(item, handle)) {
        return;
      }
      item = getParent(item); // drag target should be a top element
      if (!item) {
        return;
      }
    }
    var source = getParent(item);
    if (!source) {
      return;
    }
    if (o.invalid(item, handle)) {
      return;
    }

    var movable = o.moves(item, source, handle, nextEl(item));
    if (!movable) {
      return;
    }

    return {
      item: item,
      source: source
    };
  }

  function canMove (item) {
    return !!canStart(item);
  }

  function manualStart (item) {
    var context = canStart(item);
    if (context) {
      start(context);
    }
  }

  function start (context) {
    if (isCopy(context.item, context.source)) {
      _copy = context.item.cloneNode(true);
      drake.emit('cloned', _copy, context.item, 'copy');
    }

    _source = context.source;
    _item = context.item;
    _initialSibling = _currentSibling = nextEl(context.item);

    drake.dragging = true;
    drake.emit('drag', _item, _source);
  }

  function invalidTarget () {
    return false;
  }

  function end () {
    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    drop(item, getParent(item));
  }

  function ungrab () {
    _grabbed = false;
    eventualMovements(true);
    movements(true);
  }

  function release (e) {
    ungrab();

    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {
      drop(item, dropTarget);
    } else if (o.removeOnSpill) {
      remove();
    } else {
      cancel();
    }
  }

  function drop (item, target) {
    var parent = getParent(item);
    if (_copy && o.copySortSource && target === _source) {
      parent.removeChild(_item);
    }
    if (isInitialPlacement(target)) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, target, _source, _currentSibling);
    }
    cleanup();
  }

  function remove () {
    if (!drake.dragging) {
      return;
    }
    var item = _copy || _item;
    var parent = getParent(item);
    if (parent) {
      parent.removeChild(item);
    }
    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);
    cleanup();
  }

  function cancel (revert) {
    if (!drake.dragging) {
      return;
    }
    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;
    var item = _copy || _item;
    var parent = getParent(item);
    var initial = isInitialPlacement(parent);
    if (initial === false && reverts) {
      if (_copy) {
        if (parent) {
          parent.removeChild(_copy);
        }
      } else {
        _source.insertBefore(item, _initialSibling);
      }
    }
    if (initial || reverts) {
      drake.emit('cancel', item, _source, _source);
    } else {
      drake.emit('drop', item, parent, _source, _currentSibling);
    }
    cleanup();
  }

  function cleanup () {
    var item = _copy || _item;
    ungrab();
    removeMirrorImage();
    if (item) {
      classes.rm(item, 'gu-transit');
    }
    if (_renderTimer) {
      clearTimeout(_renderTimer);
    }
    drake.dragging = false;
    if (_lastDropTarget) {
      drake.emit('out', item, _lastDropTarget, _source);
    }
    drake.emit('dragend', item);
    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;
  }

  function isInitialPlacement (target, s) {
    var sibling;
    if (s !== void 0) {
      sibling = s;
    } else if (_mirror) {
      sibling = _currentSibling;
    } else {
      sibling = nextEl(_copy || _item);
    }
    return target === _source && sibling === _initialSibling;
  }

  function findDropTarget (elementBehindCursor, clientX, clientY) {
    var target = elementBehindCursor;
    while (target && !accepted()) {
      target = getParent(target);
    }
    return target;

    function accepted () {
      var droppable = isContainer(target);
      if (droppable === false) {
        return false;
      }

      var immediate = getImmediateChild(target, elementBehindCursor);
      var reference = getReference(target, immediate, clientX, clientY);
      var initial = isInitialPlacement(target, reference);
      if (initial) {
        return true; // should always be able to drop it right back where it was
      }
      return o.accepts(_item, target, _source, reference);
    }
  }

  function drag (e) {
    if (!_mirror) {
      return;
    }
    e.preventDefault();

    var clientX = getCoord('clientX', e);
    var clientY = getCoord('clientY', e);
    var x = clientX - _offsetX;
    var y = clientY - _offsetY;

    _mirror.style.left = x + 'px';
    _mirror.style.top = y + 'px';

    var item = _copy || _item;
    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);
    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);
    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;
    if (changed || dropTarget === null) {
      out();
      _lastDropTarget = dropTarget;
      over();
    }
    var parent = getParent(item);
    if (dropTarget === _source && _copy && !o.copySortSource) {
      if (parent) {
        parent.removeChild(item);
      }
      return;
    }
    var reference;
    var immediate = getImmediateChild(dropTarget, elementBehindCursor);
    if (immediate !== null) {
      reference = getReference(dropTarget, immediate, clientX, clientY);
    } else if (o.revertOnSpill === true && !_copy) {
      reference = _initialSibling;
      dropTarget = _source;
    } else {
      if (_copy && parent) {
        parent.removeChild(item);
      }
      return;
    }
    if (
      (reference === null && changed) ||
      reference !== item &&
      reference !== nextEl(item)
    ) {
      _currentSibling = reference;
      dropTarget.insertBefore(item, reference);
      drake.emit('shadow', item, dropTarget, _source);
    }
    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }
    function over () { if (changed) { moved('over'); } }
    function out () { if (_lastDropTarget) { moved('out'); } }
  }

  function spillOver (el) {
    classes.rm(el, 'gu-hide');
  }

  function spillOut (el) {
    if (drake.dragging) { classes.add(el, 'gu-hide'); }
  }

  function renderMirrorImage () {
    if (_mirror) {
      return;
    }
    var rect = _item.getBoundingClientRect();
    _mirror = _item.cloneNode(true);
    _mirror.style.width = getRectWidth(rect) + 'px';
    _mirror.style.height = getRectHeight(rect) + 'px';
    classes.rm(_mirror, 'gu-transit');
    classes.add(_mirror, 'gu-mirror');
    o.mirrorContainer.appendChild(_mirror);
    touchy(documentElement, 'add', 'mousemove', drag);
    classes.add(o.mirrorContainer, 'gu-unselectable');
    drake.emit('cloned', _mirror, _item, 'mirror');
  }

  function removeMirrorImage () {
    if (_mirror) {
      classes.rm(o.mirrorContainer, 'gu-unselectable');
      touchy(documentElement, 'remove', 'mousemove', drag);
      getParent(_mirror).removeChild(_mirror);
      _mirror = null;
    }
  }

  function getImmediateChild (dropTarget, target) {
    var immediate = target;
    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {
      immediate = getParent(immediate);
    }
    if (immediate === documentElement) {
      return null;
    }
    return immediate;
  }

  function getReference (dropTarget, target, x, y) {
    var horizontal = o.direction === 'horizontal';
    var reference = target !== dropTarget ? inside() : outside();
    return reference;

    function outside () { // slower, but able to figure out any position
      var len = dropTarget.children.length;
      var i;
      var el;
      var rect;
      for (i = 0; i < len; i++) {
        el = dropTarget.children[i];
        rect = el.getBoundingClientRect();
        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }
        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }
      }
      return null;
    }

    function inside () { // faster, but only available if dropped inside a child element
      var rect = target.getBoundingClientRect();
      if (horizontal) {
        return resolve(x > rect.left + getRectWidth(rect) / 2);
      }
      return resolve(y > rect.top + getRectHeight(rect) / 2);
    }

    function resolve (after) {
      return after ? nextEl(target) : target;
    }
  }

  function isCopy (item, container) {
    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);
  }
}

function touchy (el, op, type, fn) {
  var touch = {
    mouseup: 'touchend',
    mousedown: 'touchstart',
    mousemove: 'touchmove'
  };
  var pointers = {
    mouseup: 'pointerup',
    mousedown: 'pointerdown',
    mousemove: 'pointermove'
  };
  var microsoft = {
    mouseup: 'MSPointerUp',
    mousedown: 'MSPointerDown',
    mousemove: 'MSPointerMove'
  };
  if (global.navigator.pointerEnabled) {
    crossvent[op](el, pointers[type], fn);
  } else if (global.navigator.msPointerEnabled) {
    crossvent[op](el, microsoft[type], fn);
  } else {
    crossvent[op](el, touch[type], fn);
    crossvent[op](el, type, fn);
  }
}

function whichMouseButton (e) {
  if (e.touches !== void 0) { return e.touches.length; }
  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261
  if (e.buttons !== void 0) { return e.buttons; }
  var button = e.button;
  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575
    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);
  }
}

function getOffset (el) {
  var rect = el.getBoundingClientRect();
  return {
    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),
    top: rect.top + getScroll('scrollTop', 'pageYOffset')
  };
}

function getScroll (scrollProp, offsetProp) {
  if (typeof global[offsetProp] !== 'undefined') {
    return global[offsetProp];
  }
  if (documentElement.clientHeight) {
    return documentElement[scrollProp];
  }
  return doc.body[scrollProp];
}

function getElementBehindPoint (point, x, y) {
  var p = point || {};
  var state = p.className;
  var el;
  p.className += ' gu-hide';
  el = doc.elementFromPoint(x, y);
  p.className = state;
  return el;
}

function never () { return false; }
function always () { return true; }
function getRectWidth (rect) { return rect.width || (rect.right - rect.left); }
function getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }
function getParent (el) { return el.parentNode === doc ? null : el.parentNode; }
function isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }
function isEditable (el) {
  if (!el) { return false; } // no parents were editable
  if (el.contentEditable === 'false') { return false; } // stop the lookup
  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain
  return isEditable(getParent(el)); // contentEditable is set to 'inherit'
}

function nextEl (el) {
  return el.nextElementSibling || manually();
  function manually () {
    var sibling = el;
    do {
      sibling = sibling.nextSibling;
    } while (sibling && sibling.nodeType !== 1);
    return sibling;
  }
}

function getEventHost (e) {
  // on touchend event, we have to use `e.changedTouches`
  // see http://stackoverflow.com/questions/7192563/touchend-event-properties
  // see https://github.com/bevacqua/dragula/issues/34
  if (e.targetTouches && e.targetTouches.length) {
    return e.targetTouches[0];
  }
  if (e.changedTouches && e.changedTouches.length) {
    return e.changedTouches[0];
  }
  return e;
}

function getCoord (coord, e) {
  var host = getEventHost(e);
  var missMap = {
    pageX: 'clientX', // IE8
    pageY: 'clientY' // IE8
  };
  if (coord in missMap && !(coord in host) && missMap[coord] in host) {
    coord = missMap[coord];
  }
  return host[coord];
}

module.exports = dragula;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/ticky/ticky-browser.js":
/*!*********************************************!*\
  !*** ./node_modules/ticky/ticky-browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {var si = typeof setImmediate === 'function', tick;
if (si) {
  tick = function (fn) { setImmediate(fn); };
} else {
  tick = function (fn) { setTimeout(fn, 0); };
}

module.exports = tick;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/chrome-options.js":
/*!*******************************!*\
  !*** ./src/chrome-options.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var dragula__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dragula */ "./node_modules/dragula/dragula.js");
/* harmony import */ var dragula__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dragula__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hyperscript_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hyperscript.js */ "./src/hyperscript.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./src/dom.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ "./src/util.js");
/* global chrome, CP */

__webpack_require__(/*! c-p */ "./node_modules/c-p/color-picker.js");
__webpack_require__(/*! c-p/color-picker.css */ "./node_modules/c-p/color-picker.css");


__webpack_require__(/*! dragula/dist/dragula.css */ "./node_modules/dragula/dist/dragula.css");





(() => {
  // Expose this library.
  chrome.options = {};
  chrome.options.base = {};
  chrome.options.opts = {
    // If not given, title of the page will be set to the extension's name.
    // Set to `false` if you want to hide the title.
    title: null,

    // Set this if you want to customize the about tab's contents,
    // otherwise it will be set to the extension's description.
    // Set to `false` if you don't want an About page.
    about: null,

    // True if you want settings to be saved as they are changed.
    autoSave: true,

    // True if you want default values to be saved when user visits
    // the options page. Useful if you want to only specify default values
    // in one place, without having to check if an option is set.
    // Note that it requires the options page to be visited once.
    saveDefaults: true,
  };


  const $menu = document.querySelector('#main-menu');
  const $mainview = document.querySelector('.mainview');
  let lastHash = null;
  let hashPath = window.location.hash.split('.');
  let hashOption = hashPath.length > 1;
  let hashPosition = 1;

  const menuClick = () => {
    const newHash = window.location.hash;
    if (!newHash) {
      document.querySelector('.mainview > *:nth-child(2)')
        .classList.add('selected');
      document.querySelector('#main-menu li:first-child')
        .classList.add('selected');
      return;
    }
    if (newHash === lastHash) { return; }
    lastHash = newHash;

    document.querySelectorAll('.mainview > *, .menu li').forEach((el) => {
      el.classList.remove('selected');
    });

    hashPath = newHash.split('.');
    hashOption = hashPath.length > 1;

    const $currentView = document.querySelector(hashPath[0]);
    if ($currentView) {
      document.querySelector('.menu a[href="' + hashPath[0] + '"]')
        .parentNode.classList.add('selected');
      $currentView.classList.add('selected');
      document.body.scrollTop = 0;
    }
  };

  setTimeout(menuClick, 100);
  window.addEventListener('hashchange', menuClick);

  const urlParams = {};
  window.location.search.substring(1).split('&').forEach((param) => {
    urlParams[param] = true;
  });

  const changedValues = {};
  const $saveContainer = document.querySelector('.save-container');
  const $saveButton = $saveContainer.querySelector('button');
  $saveButton.addEventListener('click', () => {
    chrome.storage.sync.set(changedValues);
    $saveButton.setAttribute('disabled', true);
  });
  const showSavedAlert = _dom_js__WEBPACK_IMPORTED_MODULE_2__["flashClass"]($saveContainer, 'show', 2000);
  const flashSavedAlert = _dom_js__WEBPACK_IMPORTED_MODULE_2__["flashClass"]($saveContainer, 'flash', 150);

  // Add the extension's title to the top of the page.
  let setupRan = false;
  const setup = () => {
    if (setupRan) { return; }
    const manifest = chrome.runtime.getManifest();

    const extensionName =
      chrome.options.opts.title || manifest.name || 'chrome';
    document.querySelector('title').textContent =
      extensionName + ' options';
    const $title = document.querySelector('.chrome-options-title');
    $title.textContent = extensionName;
    if (chrome.options.opts.title !== false && !urlParams.hideTitle) {
      document.body.classList.add('show-title');
    }

    if (chrome.options.opts.about !== false &&
       (chrome.options.opts.about || manifest.description) &&
        !urlParams.hideAbout) {
      document.body.classList.add('show-about');
      let $about = document.querySelector('#about .content > p');
      if (chrome.options.opts.about) {
        $about.innerHTML = chrome.options.opts.about;
      } else {
        $about.textContent = manifest.description;
      }
    }

    if (!manifest.options_ui || manifest.options_ui.open_in_tab) {
      document.body.classList.add('open-in-tab');
    }

    if (!urlParams.hideSidebar) {
      document.body.classList.add('show-sidebar');
    }

    if (!urlParams.hideTabTitle) {
      document.body.classList.add('show-tab-title');
    }

    if (!urlParams.hideTabDesc) {
      document.body.classList.add('show-tab-desc');
    }

    if (chrome.options.opts.autoSave) {
      $saveButton.style.display = 'none';
    } else {
      $saveContainer.querySelector('.auto').style.display = 'none';
      $saveContainer.classList.add('show');
    }

    setupRan = true;
  };

  /**
   * @param {string} name
   * @param {!string} desc Will be placed at the top of the page of the tab
   * @param {Array.<Object>} options
   */
  chrome.options.addTab = (name, desc, options) => {
    setup();
    if (!options) {
      options = desc;
      desc = null;
    }
    const keyName = name.toLowerCase().replace(' ', '_');
    const $menuButton = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('li', Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('a', { href: `#${keyName}` }, name));
    $menuButton.querySelector('a').addEventListener('click', menuClick);
    $menu.append($menuButton);
    const $tabview = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('div', { id: keyName }, Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('header', Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('h1', name)));
    const $tabcontent = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('div.content');
    if (desc) {
      $tabcontent.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('p.tab-desc', desc));
    }

    const keys = [];
    const getOptionKeys = (options) => {
      options.forEach((option) => {
        if (option.name) {
          keys.push(getKeyPath(keyName, option));
        } else if (option.type === 'column' || option.type === 'row') {
          getOptionKeys(option.options);
        }
      });
    };
    getOptionKeys(options);

    chrome.storage.sync.get(keys, (items) => {
      addTabOptions($tabcontent, keyName, items, options);
    });
    $tabview.append($tabcontent);
    $mainview.append($tabview);
  };


  /**
   * @param {!string} desc
   * @param {Array.<Object>} options
   */
  chrome.options.set = (desc, options) => {
    urlParams.hideSidebar = true;
    urlParams.hideTabTitle = true;
    chrome.options.addTab('', desc, options);
  };

  const getKeyPath = (parentKey, option) => {
    return (parentKey || '') +
      (parentKey && option.name ? '.' : '') + (option.name || '');
  };

  const addTabOptions = ($parent, keyName, values, options) => {
    options.forEach((option) => {
      const key = getKeyPath(keyName, option);
      let value = values[key];
      let latestValue = value;

      // Clone value so that it can be compared to new value.
      const cloneValue = () => { value = _util_js__WEBPACK_IMPORTED_MODULE_3__["deepClone"](latestValue); };
      $saveButton.addEventListener('click', cloneValue);

      // Use requestAnimationFrame whenever possible,
      // so that it doensn't seep into load time.
      requestAnimationFrame(cloneValue);

      const save = (newValue) => {
        latestValue = newValue;

        requestAnimationFrame(() => {
          const isEqual = _util_js__WEBPACK_IMPORTED_MODULE_3__["deepEqual"](value, newValue);
          if (chrome.options.opts.autoSave) {
            if (!isEqual) {
              chrome.storage.sync.set({ [key]: newValue });
              showSavedAlert();
              flashSavedAlert();
              cloneValue();
            }
          } else if (isEqual) {
            delete changedValues[key];
            if (!Object.keys(changedValues).length) {
              $saveButton.setAttribute('disabled', true);
            } else {
              flashSavedAlert();
            }
          } else {
            changedValues[key] = newValue;
            $saveButton.removeAttribute('disabled');
            flashSavedAlert();
          }
        });
      };
      const $container = addOption(key, values, value, save, option, top);
      if ($container) { $parent.append($container); }
    });
  };

  const addH3 = (option) => !hashOption && Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('h3', option.desc);
  const addHtml = (option) => !hashOption && Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('', { innerHTML: option.html });

  const addOption = (key, values, value, save, option, top) => {
    if (hashOption) {
      if (hashPosition < hashPath.length &&
          option.name && option.name !== hashPath[hashPosition]) {
        return;
      }
      hashPosition++;
    }

    if (value === undefined && option.default != null) {
      value = option.default;
      if (chrome.options.opts.saveDefaults) {
        save(value);
      }
    }

    let $option, r;
    switch (option.type) {
      case 'checkbox':
        $option = chrome.options.base.checkbox(value, save, option, key);
        break;
      case 'object':
        $option = chrome.options.base.object(value, save, option, key);
        break;
      case 'list':
        $option = chrome.options.base.list(value, save, option, key);
        break;
      case 'column':
        $option = chrome.options.base.column(values, save, option, key, top);
        break;
      case 'row':
        $option = chrome.options.base.row(values, save, option, key, top);
        break;
      case 'h3':
        $option = addH3(option);
        break;
      case 'html':
        $option = addHtml(option);
        break;
      default:
        if (!option.type) {
          $option = chrome.options.base.checkbox(value, save, option, key);
        } else if (chrome.options.fields[option.type]) {
          $option = chrome.options.addLabelNField(value, save, option);
        } else if ((r = /(\w+)-list/.exec(option.type))) {
          $option = chrome.options.base
            .singleFieldList(value, save, option, r[1]);
        } else if ((r = /checkbox-(\w+)/.exec(option.type))) {
          $option = chrome.options.base
            .checkboxNField(value, save, option, r[1]);
        } else {
          throw Error('Could not find option type: ' + option.type);
        }
    }

    if (hashOption) { hashPosition--; }
    if (option.preview) {
      const $label = $option.querySelector('label');
      $label.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.preview-container', Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.preview')),
        Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('img.preview-image', { src: 'previews/' + key + '.' + option.preview }));
    }

    return $option;
  };

  chrome.options.base.checkbox = (value, save, option, key) => {
    const $label = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('label');
    const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.checkbox', $label);
    let $subContainer, $triangle;
    const options = option.options;
    const hasOptions = !!options;

    let checked = value;
    if (hasOptions) {
      if (value == null || typeof value !== 'object') {
        value = {};
      }
      checked = value.enabled;
    }

    const $checkbox = chrome.options.fields.checkbox(checked, (checked) => {
      if (hasOptions) {
        value.enabled = checked;
      } else {
        value = checked;
      }
      save(value);
    }, option);
    $label.append($checkbox);

    if (hasOptions) {
      $subContainer = addOptions(value, save, option, key);
      $container.append($subContainer);
      if (!checked) { $subContainer.style.display = 'none'; }

      const toggleContainer = (checked) => {
        if (checked) {
          $triangle.textContent = '';
          _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideYShow"]($subContainer);
        } else {
          $triangle.textContent = '';
          _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideYHide"]($subContainer);
        }
      };

      $triangle = $label.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.triangle', checked ? '' : ''));
      $triangle.addEventListener('click', (e) => {
        e.preventDefault();
        checked = !checked;
        toggleContainer(checked);
      });

      $checkbox.addEventListener('change', () => {
        checked = $checkbox.checked;
        toggleContainer(checked);
      });
    }

    $label.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span', option.desc));
    return $container;
  };

  chrome.options.base.checkboxNField = (value, save, option, type) => {
    if (value == null || typeof value !== 'object') {
      value = {};
    }
    let mustSave = false;
    if (value.enabled === undefined && option.defaultEnabled !== undefined) {
      value.enabled = option.defaultEnabled;
      mustSave = true;
    }
    if (value.value === undefined && option.defaultValue !== undefined) {
      value.value = option.defaultValue;
      mustSave = true;
    }
    if (mustSave && chrome.options.opts.saveDefaults) {
      save(value);
    }

    if (!chrome.options.fields[type]) {
      throw Error('Could not find option type: ' + type);
    }
    const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.suboption');
    const $box = $container.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span'));

    $box
      .append(chrome.options.fields.checkbox(value.enabled, (checked) => {
        value.enabled = checked;
        save(value);
      }, option));

    $container.append(chrome.options.addField(value.value, (newValue) => {
      value.value = newValue;
      save(value);
    }, option, type));

    if (option.desc) {
      $container.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('label', option.desc));
    }
    return $container;
  };

  chrome.options.base.object = (value, save, option, key) => {
    const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.object', Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('label', option.desc));
    $container.append(addOptions(value, save, option, key));
    return $container;
  };

  const addOptions = (value, save, option, key) => {
    if (value == null || typeof value !== 'object') {
      value = {};
    }
    const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.suboptions');
    option.options.forEach((option) => {
      const optionKey = getKeyPath(key, option);
      const $option = addOption(optionKey, value, value[option.name],
        (newValue) => {
          if (option.name) { value[option.name] = newValue; }
          save(value);
        }, option);
      if ($option) { $container.append($option); }
    });
    return $container;
  };

  chrome.options.addLabelNField = (value, save, option) => {
    const $label = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('label');
    $label.innerHTML = option.desc || '';
    const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.suboption', $label);
    const $field = chrome.options.addField(value, save, option);
    $container.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.field-container', $field));
    $container.classList.add(option.singleline ? 'singleline' : 'multiline');
    return $container;
  };

  chrome.options.base.list = (list, save, options, key) => {
    const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.suboption.list');
    let $wrapper, shown = true;

    if (options.desc) {
      const $label = $container.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('label', options.desc));
      if (options.collapsible) {
        shown = false;
        const $triangle = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.triangle', {
          onclick: () => {
            shown = !shown;
            if (shown) {
              $triangle.textContent = '';
              _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideYShow"]($wrapper);
            } else {
              $triangle.textContent = '';
              _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideYHide"]($wrapper);
            }
          },
        }, '');
        $label.prepend($triangle);
      }
    }

    list = list || [];
    const $table = $container.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('table'));
    if (options.desc && options.collapsible) {
      $wrapper = $container.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('', { style: 'display: none' }, $table));
    }
    const $tbody = $table.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('tbody'));
    let rows;
    let heads = {};

    if (options.head) {
      const $thead = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('tr');
      let prevfield;
      options.fields.forEach((field) => {
        if (!field.bindTo || !prevfield.bindTo) {
          const $container = heads[field.name] = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('div', field.desc);
          $thead.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('th', $container));
        } else {
          heads[field.name] = heads[prevfield.name];
        }
        prevfield = field;
      });
      $table.prepend(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('thead', $thead));
    }

    // Check if each column should be shown.
    const checkColumns = (init) => {
      options.fields.forEach((field) => {
        if (!field.bindTo) { return; }
        const show = rows.some(row => row.shown[field.name]);
        const $head = heads[field.name];
        const isVisible = !!$head.offsetParent;
        if (show && !isVisible) {
          setTimeout(_dom_js__WEBPACK_IMPORTED_MODULE_2__["slideXShow"].bind(null, $head), init ? 0 : 500);
        } else if (!show && isVisible) {
          if (init) {
            $head.style.display = 'none';
          } else {
            _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideXHide"]($head);
          }
        }
      });
    };

    const saveFields = () => {
      const newValues = rows.map(getValue => getValue());
      save(newValues.filter((rowValue) => {
        if (rowValue == null || rowValue === '') {
          return false;
        } else if (options.filter && !options.filter(rowValue)) {
          return false;
        } else if (typeof rowValue === 'object') {
          for (let field of options.fields) {
            if (field.required && !rowValue[field.name]) {
              return false;
            }
          }
          return Object.keys(rowValue).some(key => rowValue[key] != null);
        }
        return true;
      }));
      requestAnimationFrame(() => {
        rows.forEach((row) => { row.update(newValues); });
        if (options.head) { checkColumns(false); }
      });
    };

    const fieldsMap = {};
    options.fields.forEach((field) => { fieldsMap[field.name] = field; });

    const addNewRow = (animate) => {
      let row;
      const remove = () => {
        rows.splice(rows.indexOf(row), 1);
        saveFields();
      };
      row = addListRow($tbody, null, options.fields, fieldsMap, saveFields,
        remove, false, options.sortable, animate, key);
      rows.push(row);
      requestAnimationFrame(() => {
        const rowValues = rows.map(getValue => getValue());
        rows.forEach((row) => { row.update(rowValues); });
      });
    };

    rows = list.map((rowData, i) => {
      let row;
      const remove = () => {
        rows.splice(rows.indexOf(row), 1);
        saveFields();
      };
      const fields = i === 0 && options.first ? options.first : options.fields;
      row = addListRow($tbody, rowData, fields, fieldsMap, saveFields,
        remove, i === 0 && options.first,
        options.sortable, false, key);
      return row;
    });

    if (options.first && !rows.length) {
      const row = addListRow($tbody, null, options.first, fieldsMap,
        saveFields, () => {}, true, options.sortable, false, key);
      rows.push(row);
      saveFields();
    }

    // Always start with one new row.
    addNewRow();

    // Check if columns with the `bindTo` should be displayed.
    if (options.head) {
      requestAnimationFrame(checkColumns.bind(null, true));
    }

    // When user edits the last row, add another.
    const onChange = (e) => {
      if ($tbody.lastChild.contains(e.target)) {
        addNewRow(true);
      }
    };

    $tbody.addEventListener('input', onChange);
    $tbody.addEventListener('change', onChange);

    if (options.sortable) {
      dragula__WEBPACK_IMPORTED_MODULE_0___default()([$tbody], {
        moves: (el, source, handle) => {
          return (!options.first || el != el.parentNode.children[0]) &&
            handle.classList.contains('sort') &&
            handle.closest('tbody') == $tbody;
        },
        accepts: (el, target, source, sibling) => {
          return !sibling.classList.contains('gu-mirror');
        },
        direction: 'vertical',
        mirrorContainer: $tbody,

      }).on('cloned', ($mirror, $original) => {
        // Set the mirror's td's to a fixed width since taking a row
        // out of a table removes its alignments from the
        // table's columns.
        const $mirrorTDs = $mirror.querySelectorAll(':scope > td');
        $original.querySelectorAll(':scope > td').forEach(($td, i) => {
          $mirrorTDs[i].style.width = $td.offsetWidth + 'px';
        });

        // Copy the value of the mirror's form elements.
        // Since `node.cloneNode()` does not do so for some of them.
        const selection = 'select, input[type=radio]';
        const $mirrorFields = $mirror.querySelectorAll(selection);
        $original.querySelectorAll(selection).forEach(($field, i) => {
          const $node = $mirrorFields[i];
          $node.value = $field.value;
          if ($node.checked) {
            // Change the name of the radio field so that checking the
            // original element again won't uncheck the mirrored element.
            $node.setAttribute('name', $node.getAttribute('name') + '_');
            $field.checked = true;
          }
        });

      }).on('dragend', () => {
        rows.forEach((a) => {
          let $child = a.$tr;
          a.index = 0;
          while (($child = $child.previousSibling) != null) { a.index++; }
        });
        rows.sort((a, b) => a.index - b.index);
        saveFields();
      });
    }

    return $container;
  };

  const addListRow = ($table, values, fields, fieldsMap, save, remove,
    unremovable, sort, animate, key) => {
    const $tr = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('tr');
    if (unremovable) {
      $tr.classList.add('unremovable');
    }
    if (animate) {
      $tr.style.display = 'none';
      setTimeout(_dom_js__WEBPACK_IMPORTED_MODULE_2__["showTR"].bind(null, $tr), 100);
    }

    const getValue = () => values;
    getValue.$tr = $tr;

    // Keep track which fields in this row are being shown.
    getValue.shown = {};

    let $prevtd, prevfield;
    const fieldUpdates = fields.map((field) => {
      const saveField = (newValue) => {
        const name = field.name;
        if (fields.length === 1) {
          values = newValue;
        } else if (name) {
          values[name] = newValue;
        }
        fieldUpdates.forEach((up) => { up.checkBind(name, newValue); });
        save();
      };

      let $field;
      const update = {};
      update.checkBind = (name, newValue) => {
        const bindTo = field.bindTo;
        if (bindTo && bindTo.field === name) {
          const isVisible = !!$field.offsetParent;
          const equals = bindToEquals(bindTo.value, newValue);
          if (equals && !isVisible) {
            _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideXShow"]($field);
            getValue.shown[field.name] = true;
          } else if (!equals && isVisible) {
            _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideXHide"]($field);
            getValue.shown[field.name] = false;
          }
        }
      };

      update.hide = () => {
        if (field.bindTo) {
          _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideXHide"]($field);
        }
      };

      update.checkSelect = (newValues) => {
        if (field.type === 'select') {
          field.options
            .filter(f => f.unique)
            .forEach((option) => {
              const display = newValues.some((rowValue) => {
                return rowValue !== values &&
                  rowValue[field.name] === option.value;
              }) ? 'none' : '';
              $field
                .querySelector('option[value="' + option.value + '"]')
                .style.display = display;
            });
        }
      };

      const bindTo = field.bindTo;
      const $td = bindTo && prevfield && prevfield.bindTo ?
        $prevtd : Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('td');
      if (bindTo) {
        $td.classList.add('bind-to');
      }
      $prevtd = $td;
      prevfield = field;
      const $fieldContainer = $tr.appendChild($td);
      let fieldValue;
      if (!values && (fields.length > 1 ||
          field.type === 'column' || field.type === 'row')) {
        values = {};
      }

      if (fields.length === 1) {
        fieldValue = values = values !== undefined ? values : field.default;
      } else {
        fieldValue = values[field.name] =
          values[field.name] !== undefined ? values[field.name] : field.default;
      }

      if (chrome.options.fields[field.type]) {
        $field = chrome.options.addField(fieldValue, saveField, field);
      } else if (field.type === 'column') {
        $field = chrome.options.base.column(values, save, field, key);
      } else if (field.type === 'row') {
        $field = chrome.options.base.row(values, save, field, key);
      } else {
        throw Error('Could not find option type: ' + field.type);
      }
      $fieldContainer.append($field);

      requestAnimationFrame(() => {
        if (!bindTo) { return; }
        if (
          (values[bindTo.field] &&
           !bindToEquals(bindTo.value, values[bindTo.field])) ||
          (!values[bindTo.field] &&
           !bindToEquals(bindTo.value,
             fieldsMap[bindTo.field].options[0].value))
        ) {
          $field.style.display = 'none';
          getValue.shown[field.name] = false;
        } else {
          if (animate) {
            setTimeout(() => {
              _dom_js__WEBPACK_IMPORTED_MODULE_2__["slideXShow"]($field);
            }, 500);
          } else {
            $field.style.display = '';
            $field.style.maxWidth = '100%;';
          }
          getValue.shown[field.name] = true;
        }
      });

      return update;
    });

    $tr.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('td', Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('a.delete', {
      onclick: () => {
        fieldUpdates.forEach((update) => { update.hide(); });
        setTimeout(() => {
          _dom_js__WEBPACK_IMPORTED_MODULE_2__["hideTR"]($tr, () => { $tr.remove(); });
        }, 250);
        remove();
      },
    }, 'delete')));
    
    if (!unremovable && sort) {
      $tr.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('td', Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('a.sort', 'sort')));
    }
    $table.append($tr);

    getValue.update = (newValues) => {
      fieldUpdates.forEach((update) => {
        update.checkSelect(newValues);
      });
    };

    return getValue;
  };

  const bindToEquals = (bindToValue, fieldValue) => {
    return Array.isArray(bindToValue) ?
      bindToValue.indexOf(fieldValue) > -1 : bindToValue === fieldValue;
  };

  chrome.options.base.singleFieldList = (value, save, options, type) => {
    options.fields = [{ type: type, name: options.name }];
    return chrome.options.base.list(value, save, options);
  };

  chrome.options.base.column = (values, save, option, key, top) => {
    delete option.name;
    let $container;
    if (top) {
      $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('div.column');
      addTabOptions($container, key, values, option.options);
    } else {
      $container = addOptions(values, save, option, key);
      $container.classList.add('column');
    }
    return $container;
  };

  chrome.options.base.row = (values, save, option, key, top) => {
    const $container =
      chrome.options.base.column(values, save, option, key, top);
    $container.classList.add('row');
    return $container;
  };

  chrome.options.addField = (value, save, option, type) => {
    const fn = chrome.options.fields[type || option.type];
    if (!fn) { return; }
    let lastTimeStamp;
    const $field = fn(value, (newValue, e) => {
      if (e) {
        if (e.timeStamp < lastTimeStamp) { return; }
        lastTimeStamp = e.timeStamp;
      }
      if (option.validate && !option.validate(newValue)) {
        $field.classList.add('invalid');
      } else {
        $field.classList.remove('invalid');
        save(newValue, e);
      }
    }, option);
    if (option.desc) {
      $field.setAttribute('data-title', option.desc);
    }
    if (option.disabled) {
      $field.setAttribute('disabled', true);
      $field.querySelectorAll(':scope, input, select, textarea').forEach(($f) => {
        $f.setAttribute('disabled', true);
      });
    }
    return $field;
  };
})();


// Define all available fields.
chrome.options.fields = {};

chrome.options.fields.checkbox = (value, save) => {
  const $checkbox = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('input[type=checkbox]');

  if (value != null) {
    $checkbox.checked = value;
  }

  $checkbox.addEventListener('change', () => {
    save($checkbox.checked);
  });

  return $checkbox;
};

chrome.options.fields.text = (value, save) => {
  const $textbox = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('input[type=text]');
  if (value !== undefined) {
    $textbox.value = value;
  }
  const debouncedInput = _util_js__WEBPACK_IMPORTED_MODULE_3__["debounce"](500, (e) => {
    if (e.target.validity.valid) {
      save($textbox.value, e);
    }
  });
  $textbox.addEventListener('input', debouncedInput);
  $textbox.addEventListener('change', debouncedInput);
  return $textbox;
};

chrome.options.fields.color = (value, save, option) => {
  let first = true;
  const format = option.format || 'rgba';
  if (!['rgb', 'rgba', 'hsl', 'hsla', 'hex'].includes(format)) {
    throw TypeError('Unsupported format given for color field: ' + format);
  }
  const showAlpha = ['rgba', 'hsla'].includes(format);
  const hsv2hsl = (d) => {
    return [
      Math.round(d[0] * 360),
      Math.round(d[1] * 100) + '%',
      Math.round(d[2] * 100) + '%'
    ];
  };
  const fn = {
    rgb: CP._HSV2RGB, rgba: CP._HSV2RGB,
    hsl: hsv2hsl, hsv2hsl,
    hex: CP._HSV2HEX,
  }[format];
  const debouncedSave = _util_js__WEBPACK_IMPORTED_MODULE_3__["debounce"](500, save);
  const onchange = () => {
    if (first) { return first = false; }
    const v = fn(picker.set());
    const color = /^hex/.test(format) ?
      `#${v}` :
      `${format}(${v.join(', ')}${showAlpha ? `, ${$alpha.value}` : ''})`;
    $field.value = color;
    $color.style.backgroundColor = color;
    debouncedSave(color);
  };

  const getAlpha = (value) => {
    const r = /(?:rgba|hsla)\(\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(\d?(?:\.\d+)?)\s*\)/
      .exec(value);
    return r && r[1] != '' ? r[1] : 1;
  };

  const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.color');
  $container.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.color-alpha'));
  const $color = $container.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.color-box', {
    style: value ? `background-color: ${value};` : '',
    onclick: () => { picker.enter(); },
  }));
  const $field = chrome.options.fields.text(value, () => {
    if ($alpha) {
      $alpha.value = getAlpha($field.value);
    }

    // color-picker doesn't accept alpha, so take it out.
    let s = $field.value .split(',');
    s = s.length >=4 ? s.slice(0, 3).join(',') + ')' : s.join(',');
    s = s.replace('rgba', 'rgb').replace('hsla', 'hsv').replace('hsl', 'hsv');
    picker.set(s);
  });
  $container.append($field);
  const picker = new CP($field);
  picker.on('change', onchange);

  const $extraOptions = picker.self.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.extra-options'));
  let $alpha;
  if (showAlpha) {
    $alpha = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('input[type=range][min=0][max=1][step=.1]', {
      'data-title': 'Alpha',
      onchange,
      oninput: onchange,
      value: value != null ? getAlpha(value) : 1,
    });
    $extraOptions.append($alpha);
  }

  if (option.default) {
    $extraOptions.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.color-reset', {
      'data-title': 'Reset to default',
      onclick: () => {
        picker.set(option.default);
        picker.trigger('change', [option.default]);
      },
      style: `background-color: ${option.default};`,
    }));
  }
  return $container;
};

chrome.options.fields.url = (value, save, option) => {
  const $field = chrome.options.fields.text(value, save, option);
  $field.setAttribute('type', 'url');
  return $field;
};

chrome.options.fields.select = (value, save, option) => {
  const valueMap = {};
  const $select = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('select', {
    onchange: (e) => {
      const val = $select.value;
      save(valueMap[val] !== undefined ? valueMap[val] : val, e);
    },
  });
  let firstValue = null;
  option.options.forEach((option) => {
    const value = typeof option === 'object' ? option.value : option ;
    const desc = typeof option === 'object' ? option.desc : option;
    valueMap[value] = value;
    $select.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('option', { value }, desc));
    if (firstValue === null) {
      firstValue = value;
    }
  });
  $select.value = value || firstValue;
  return $select;
};

chrome.options.fields.radio = (value, save, option) => {
  const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.radio-options');
  const name = (~~(Math.random() * 1e9)).toString(36);
  option.options.forEach((option) => {
    const val = typeof option === 'object' ? option.value : option;
    const desc = typeof option === 'object' ? option.desc : option;
    const id = (~~(Math.random() * 1e9)).toString(36);
    const $row = $container.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.radio-option'));
    const $radio = $row.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('input[type=radio]', {
      id, name,
      value: val,
      checked: value == val,
      onchange: (e) => {
        if ($radio.checked) {
          save(val, e);
        }
      },
    }));

    $row.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('label', { for: id }, desc));
  });

  return $container;
};

chrome.options.fields.predefined_sound = (value, save, option) => {
  const playSound = () => {
    if (!value) {
      $play.classList.add('disabled');
      return;
    }
    $play.classList.remove('disabled');
    const audio = new Audio();
    audio.src = 'bower_components/chrome-options/sounds/' + value + '.wav';
    audio.onerror = console.error;
    audio.play();
  };

  const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.predefined-sound');
  const $play = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.play', { onclick: playSound, innerHTML: '&#9654;' });

  const options = [
    'Basso', 'Bip', 'Blow', 'Boing', 'Bottle', 'Clink-Klank',
    'Droplet', 'Frog', 'Funk', 'Glass', 'Hero', 'Indigo', 'Laugh',
    'Logjam', 'Monkey', 'moof', 'Ping', 'Pong2003', 'Pop',
    'Purr', 'Quack', 'Single Click', 'Sosumi', 'Temple', 'Uh oh',
    'Voltage', 'Whit', 'Wild Eep'
  ];

  if (option.allowNoSound) {
    options.unshift({ value: '', desc: 'Select' });
    value = value || '';
    if (!value) { $play.classList.add('disabled'); }
  } else {
    value = value || options[0];
  }

  const saveField = (newValue, e) => {
    value = newValue;
    save(newValue, e);
  };

  const $field = chrome.options.fields.select(value, saveField, { options });
  $field.addEventListener('change', playSound);
  $container.append($field, $play);

  return $container;
};

chrome.options.fields.custom_sound = (value, save) => {
  const $container = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.custom-sound');

  const saveField = (newValue, e) => {
    value = newValue;
    save(newValue, e);
  };

  const playSound = () => {
    const audio = new Audio();
    audio.src = value;
    audio.play();
  };

  const $field = chrome.options.addField(value, saveField, { type: 'url' });
  $field.addEventListener('keypress', (e) => {
    if (e.keyCode === 13) {
      playSound();
    }
  });
  $container.append($field);
  $container.append(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('span.play', { onclick: playSound, innerHTML: '&#9654;' }));

  return $container;
};

chrome.options.fields.file = (value, save) => {
  return Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_1__["default"])('input[type=file]', {
    value,
    onchange: (e) => {
      save(e.target.files, e);
    },
  });
};


/***/ }),

/***/ "./src/dom.js":
/*!********************!*\
  !*** ./src/dom.js ***!
  \********************/
/*! exports provided: slideYShow, slideYHide, slideXShow, slideXHide, showTR, hideTR, flashClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideYShow", function() { return slideYShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideYHide", function() { return slideYHide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideXShow", function() { return slideXShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slideXHide", function() { return slideXHide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showTR", function() { return showTR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideTR", function() { return hideTR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flashClass", function() { return flashClass; });
/* harmony import */ var _hyperscript_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hyperscript.js */ "./src/hyperscript.js");


const animTime = 500;
const animFunc = 'ease-in-out';
const slideYShow = ($node, ms = animTime) => {
  const startingHeight = $node.offsetParent ?
    window.getComputedStyle($node).height : '0';
  $node.style.display = 'block';
  $node.style.height = 'auto';
  $node.style.paddingTop = '';
  $node.style.paddingBottom = '';
  $node.style.marginTop = '';
  $node.style.marginBottom = '';
  const height = window.getComputedStyle($node).height;
  const heightInt = parseInt(height, 10);
  $node.style.height = startingHeight;
  $node.style.paddingTop = '0';
  $node.style.paddingBottom = '0';
  $node.style.marginTop = '0';
  $node.style.marginBottom = '0';
  $node.style.overflow = 'hidden';
  if (heightInt > window.innerHeight) {
    ms *= heightInt / window.innerHeight;
  }
  $node.style.transition = `
    height ${ms}ms ${animFunc},
    padding ${ms}ms ${animFunc},
    margin ${ms}ms ${animFunc}
  `;
  setTimeout(() => {
    $node.style.height = height;
    $node.style.paddingTop = '';
    $node.style.paddingBottom = '';
    $node.style.marginTop = '';
    $node.style.marginBottom = '';
  });
};

const slideYHide = ($node, ms = animTime) => {
  $node.style.overflow = 'hidden';
  $node.style.position = 'relative';
  $node.style.paddingTop = '';
  $node.style.paddingBottom = '';
  $node.style.marginTop = '';
  $node.style.marginBottom = '';
  const height = window.getComputedStyle($node).height;
  const heightInt = parseInt(height, 10);
  $node.style.height = height;
  if (heightInt > window.innerHeight) {
    ms *= 1 + (((heightInt / window.innerHeight) - 1) / 2);
  }
  $node.style.transition = `
    height ${ms}ms ${animFunc},
    padding ${ms}ms ${animFunc},
    margin ${ms}ms ${animFunc}
  `;
  setTimeout(() => {
    $node.style.height = '0';
    $node.style.paddingTop = '0';
    $node.style.paddingBottom = '0';
    $node.style.marginTop = '0';
    $node.style.marginBottom = '0';
  });
};

const slideXShow = ($node, ms = animTime) => {
  $node.style.display = '';
  $node.style.width = '';
  $node.style.paddingLeft = '';
  $node.style.paddingRight = '';
  $node.style.marginLeft = '';
  $node.style.marginRight = '';
  const width = window.getComputedStyle($node).width;
  $node.style.width = '0';
  $node.style.paddingLeft = '0';
  $node.style.paddingRight = '0';
  $node.style.marginLeft = '0';
  $node.style.marginRight = '0';
  $node.style.transition = `
    width ${ms}ms ${animFunc},
    padding ${ms}ms ${animFunc},
    margin ${ms}ms ${animFunc}
  `;
  $node.style.overflow = 'hidden';
  $node.style.whiteSpace = 'nowrap';
  setTimeout(() => {
    $node.style.width = width;
    $node.style.paddingLeft = '';
    $node.style.paddingRight = '';
    $node.style.marginLeft = '';
    $node.style.marginRight = '';
  });
};

const slideXHide = ($node, ms = animTime) => {
  $node.style.width = window.getComputedStyle($node).width;
  $node.style.paddingLeft = '';
  $node.style.paddingRight = '';
  $node.style.marginLeft = '';
  $node.style.marginRight = '';
  $node.style.transition = `
    width ${ms}ms ${animFunc},
    padding ${ms}ms ${animFunc},
    margin ${ms}ms ${animFunc}
  `;
  $node.style.overflow = 'hidden';
  $node.style.whiteSpace = 'nowrap';
  setTimeout(() => {
    $node.style.width = '0';
    $node.style.paddingLeft = '0';
    $node.style.paddingRight = '0';
    $node.style.marginLeft = '0';
    $node.style.marginRight = '0';
    setTimeout(() => {
      $node.style.display = 'none';
    }, ms);
  });
};

const showTR = ($tr) => {
  $tr.style.display = '';
  for (let $td of $tr.children) {
    let $wrapper = $td.appendChild(Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_0__["default"])('', {
      style: 'display: none',
    }, $td.childNodes));
    window.slideYShow($wrapper);
    setTimeout(() => {
      $td.append(...$wrapper.childNodes);
      $wrapper.remove();
    }, animTime);
  }
};

const hideTR = ($tr, callback) => {
  let n = $tr.children.length;
  for (let $td of $tr.children) {
    let $wrapper = Object(_hyperscript_js__WEBPACK_IMPORTED_MODULE_0__["default"])('');
    $wrapper.append(...$td.childNodes);
    $td.append($wrapper);
    window.slideYHide($wrapper);
    setTimeout(() => {
      $tr.style.display = 'none';
      $td.append(...$wrapper.childNodes);
      $wrapper.remove();
      if (--n === 0) {
        $tr.style.display = 'none';
        if (callback) { callback(); }
      }
    }, animTime);
  }
};

const flashClass = ($node, className, ms) => {
  let timeoutID;
  return () => {
    $node.classList.add(className);
    clearTimeout(timeoutID);
    timeoutID = setTimeout(() => {
      $node.classList.remove(className);
    }, ms);
  };
};


/***/ }),

/***/ "./src/hyperscript.js":
/*!****************************!*\
  !*** ./src/hyperscript.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const isArray = (obj) => {
  return Array.isArray(obj) ||
    obj instanceof NodeList;
};

/* harmony default export */ __webpack_exports__["default"] = ((selector, props = {}, children) => {
  if (props != null && (isArray(props) ||
    typeof props === 'string' ||
    props.tagName)) {
    children = props;
    props = {};
  }

  const attrs = {};
  const attrsRe = /\[([^\s=]+)=(?:"([^"]*)"|([^\]]*))\]/;
  let res;
  while ((res = attrsRe.exec(selector))) {
    attrs[res[1]] = res[2] || res[3];
    selector = selector.slice(0, res.index) +
      selector.slice(res.index + res[0].length);
  }

  const m = selector.split(/(\.|#)/);
  const tagName = m[0] === '.' || m[0] === '#' || m[0] === '' ?
    'div' : m[0];
  const el = document.createElement(tagName);
  for (let i = 1; i < m.length; i += 2) {
    if (m[i] === '.') {
      el.classList.add(m[i + 1]);
    } else if (m[i] === '#') {
      attrs.id = m[i + 1];
    }
  }

  for (let key in attrs) {
    el.setAttribute(key, attrs[key]);
  }

  for (let key in props) {
    let r = /^on(\w+)/.exec(key);
    let val = props[key];
    if (r) {
      el.addEventListener(r[1], val);
    } else if (key === 'innerHTML'){
      el[key] = val;
    } else if (val !== false){
      el.setAttribute(key, val);
    }
  }

  if (children != null) {
    if (isArray(children)) {
      el.append(...children);
    } else {
      el.append(children);
    }
  }

  return el;
});


/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: deepEqual, deepClone, debounce */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepEqual", function() { return deepEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepClone", function() { return deepClone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
const deepEqual = (a, b) => {
  const t1 = typeof a;
  const t2 = typeof b;
  if (t1 !== t2) { return false; }
  if (t1 !== 'object' || a == null) { return a === b; }

  const k1 = Object.keys(a).sort();
  const k2 = Object.keys(b).sort();
  if (k1.length !== k2.length) { return false; }

  for (let i = 0, len = k1.length; i < len; i++) {
    if (k1[i] !== k2[i]) { return false; }
    if (!deepEqual(a[k1[i]], b[k2[i]])) { return false; }
  }

  return true;
};

const deepClone = (obj) => {
  if (!(obj instanceof Object)) { return obj; }
  const clone = {};
  for (let prop in obj) { clone[prop] = deepClone(obj[prop]); }
  return clone;
};

const debounce = (wait, func) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
};


/***/ })

/******/ });
//# sourceMappingURL=main.min.js.map